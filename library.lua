--- Tables of colors
-- @submodule color

--- All of the named HTML colors.
-- @table htmlColors
-- @field colorname {r, g, b, a}
htmlColors = { indianred = { 205, 92, 92, 1 }, lightcoral = { 240, 128, 128, 1 }, salmon = { 250, 128, 114, 1 }, darksalmon = { 233, 150, 122, 1 }, lightsalmon = { 255, 160, 122, 1 }, crimson = { 220, 20, 60, 1 }, red = { 255, 0, 0, 1 }, firebrick = { 178, 34, 34, 1 }, darkred = { 139, 0, 0, 1 }, pink = { 255, 192, 203, 1 }, lightpink = { 255, 182, 193, 1 }, hotpink = { 255, 105, 180, 1 }, deeppink = { 255, 20, 147, 1 }, mediumvioletred = { 199, 21, 133, 1 }, palevioletred = { 219, 112, 147, 1 }, coral = { 255, 127, 80, 1 }, tomato = { 255, 99, 71, 1 }, orangered = { 255, 69, 0, 1 }, darkorange = { 255, 140, 0, 1 }, orange = { 255, 165, 0, 1 }, gold = { 255, 215, 0, 1 }, yellow = { 255, 255, 0, 1 }, lightyellow = { 255, 255, 224, 1 }, lemonchiffon = { 255, 250, 205, 1 }, lightgoldenrodyellow = { 250, 250, 210, 1 }, papayawhip = { 255, 239, 213, 1 }, moccasin = { 255, 228, 181, 1 }, peachpuff = { 255, 218, 185, 1 }, palegoldenrod = { 238, 232, 170, 1 }, khaki = { 240, 230, 140, 1 }, darkkhaki = { 189, 183, 107, 1 }, lavender = { 230, 230, 250, 1 }, thistle = { 216, 191, 216, 1 }, plum = { 221, 160, 221, 1 }, violet = { 238, 130, 238, 1 }, orchid = { 218, 112, 214, 1 }, fuchsia = { 255, 0, 255, 1 }, magenta = { 255, 0, 255, 1 }, mediumorchid = { 186, 85, 211, 1 }, mediumpurple = { 147, 112, 219, 1 }, rebeccapurple = { 102, 51, 153, 1 }, blueviolet = { 138, 43, 226, 1 }, darkviolet = { 148, 0, 211, 1 }, darkorchid = { 153, 50, 204, 1 }, darkmagenta = { 139, 0, 139, 1 }, purple = { 128, 0, 128, 1 }, indigo = { 75, 0, 130, 1 }, slateblue = { 106, 90, 205, 1 }, darkslateblue = { 72, 61, 139, 1 }, mediumslateblue = { 123, 104, 238, 1 }, greenyellow = { 173, 255, 47, 1 }, chartreuse = { 127, 255, 0, 1 }, lawngreen = { 124, 252, 0, 1 }, lime = { 0, 255, 0, 1 }, limegreen = { 50, 205, 50, 1 }, palegreen = { 152, 251, 152, 1 }, lightgreen = { 144, 238, 144, 1 }, mediumspringgreen = { 0, 250, 154, 1 }, springgreen = { 0, 255, 127, 1 }, mediumseagreen = { 60, 179, 113, 1 }, seagreen = { 46, 139, 87, 1 }, forestgreen = { 34, 139, 34, 1 }, green = { 0, 128, 0, 1 }, darkgreen = { 0, 100, 0, 1 }, yellowgreen = { 154, 205, 50, 1 }, olivedrab = { 107, 142, 35, 1 }, olive = { 128, 128, 0, 1 }, darkolivegreen = { 85, 107, 47, 1 }, mediumaquamarine = { 102, 205, 170, 1 }, darkseagreen = { 143, 188, 139, 1 }, lightseagreen = { 32, 178, 170, 1 }, darkcyan = { 0, 139, 139, 1 }, teal = { 0, 128, 128, 1 }, aqua = { 0, 255, 255, 1 }, cyan = { 0, 255, 255, 1 }, lightcyan = { 224, 255, 255, 1 }, paleturquoise = { 175, 238, 238, 1 }, aquamarine = { 127, 255, 212, 1 }, turquoise = { 64, 224, 208, 1 }, mediumturquoise = { 72, 209, 204, 1 }, darkturquoise = { 0, 206, 209, 1 }, cadetblue = { 95, 158, 160, 1 }, steelblue = { 70, 130, 180, 1 }, lightsteelblue = { 176, 196, 222, 1 }, powderblue = { 176, 224, 230, 1 }, lightblue = { 173, 216, 230, 1 }, skyblue = { 135, 206, 235, 1 }, lightskyblue = { 135, 206, 250, 1 }, deepskyblue = { 0, 191, 255, 1 }, dodgerblue = { 30, 144, 255, 1 }, cornflowerblue = { 100, 149, 237, 1 }, royalblue = { 65, 105, 225, 1 }, blue = { 0, 0, 255, 1 }, mediumblue = { 0, 0, 205, 1 }, darkblue = { 0, 0, 139, 1 }, navy = { 0, 0, 128, 1 }, midnightblue = { 25, 25, 112, 1 }, cornsilk = { 255, 248, 220, 1 }, blanchedalmond = { 255, 235, 205, 1 }, bisque = { 255, 228, 196, 1 }, navajowhite = { 255, 222, 173, 1 }, wheat = { 245, 222, 179, 1 }, burlywood = { 222, 184, 135, 1 }, tan = { 210, 180, 140, 1 }, rosybrown = { 188, 143, 143, 1 }, sandybrown = { 244, 164, 96, 1 }, goldenrod = { 218, 165, 32, 1 }, darkgoldenrod = { 184, 134, 11, 1 }, peru = { 205, 133, 63, 1 }, chocolate = { 210, 105, 30, 1 }, saddlebrown = { 139, 69, 19, 1 }, sienna = { 160, 82, 45, 1 }, brown = { 165, 42, 42, 1 }, maroon = { 128, 0, 0, 1 }, white = { 255, 255, 255, 1 }, snow = { 255, 250, 250, 1 }, honeydew = { 240, 255, 240, 1 }, mintcream = { 245, 255, 250, 1 }, azure = { 240, 255, 255, 1 }, aliceblue = { 240, 248, 255, 1 }, ghostwhite = { 248, 248, 255, 1 }, whitesmoke = { 245, 245, 245, 1 }, seashell = { 255, 245, 238, 1 }, beige = { 245, 245, 220, 1 }, oldlace = { 253, 245, 230, 1 }, floralwhite = { 255, 250, 240, 1 }, ivory = { 255, 255, 240, 1 }, antiquewhite = { 250, 235, 215, 1 }, linen = { 250, 240, 230, 1 }, lavenderblush = { 255, 240, 245, 1 }, mistyrose = { 255, 228, 225, 1 }, gainsboro = { 220, 220, 220, 1 }, lightgray = { 211, 211, 211, 1 }, silver = { 192, 192, 192, 1 }, darkgray = { 169, 169, 169, 1 }, gray = { 128, 128, 128, 1 }, dimgray = { 105, 105, 105, 1 }, lightslategray = { 119, 136, 153, 1 }, slategray = { 112, 128, 144, 1 }, darkslategray = { 47, 79, 79, 1 }, black = { 0, 0, 0, 1 } }


--- Functions to convert various color types into one another\
-- @submodule color

--- Converts a hex code string to a color table.
-- Takes a string representation of a CSS hex value and converts it into
-- an `{r, g, b, a}` color table. The function ignores the leading #
-- symbol if present and will parse a 3 (rgb), 4 (rgba), 6 (rrggbb), or
-- 8 (rrggbbaa) character-long hex value into a normalized (0 to 1) rgba
-- color table. Sets a to 1 if not present in the hex code.
-- @tparam string s A hex code formatted as #rgb, #rgba, #rrggbb, or
-- #rrggbbaa with or without the leading # symbol
-- @treturn table A color table in the format {r, g, b, a}
-- @raise ValueError if hex code is malformed
-- @usage
-- white = hex_code_to_color("#FFF")
-- print(white) -- {1, 1, 1, 1}
--
-- black = hex_code_to_color("000F")
-- print(black) -- {0, 0, 0, 1}
--
-- orange = hex_code_to_color("#FFA500")
-- print(orange) -- {0.9450..., 0.7686..., 0.0588..., 1}
--
-- blue_transparent = hex_code_to_color("0000FF33")
-- print(blue_transparent) -- {0, 0, 1, 0.2}
--
-- malformed_hex = hex_code_to_color("#G09F3")
-- -- ValueError: Not a valid hex code.
function hex_code_to_color(s)
    if not is_valid_hex_code(s) then
        error("ValueError: Not a valid hex code.")
    end

    s = tostring(s):gsub("#", "")
    local color = {}
    if #s == 3 or #s == 4 then
        table.insert(color, tonumber(s:sub(1, 1):rep(2), 16) / 255)
        table.insert(color, tonumber(s:sub(2, 2):rep(2), 16) / 255)
        table.insert(color, tonumber(s:sub(3, 3):rep(2), 16) / 255)
        table.insert(color, (#s == 4) and tonumber(s:sub(4, 4):rep(2), 16) / 255 or 1)
    elseif #s == 6 or #s == 8 then
        table.insert(color, tonumber(s:sub(1, 2), 16) / 255)
        table.insert(color, tonumber(s:sub(3, 4), 16) / 255)
        table.insert(color, tonumber(s:sub(5, 6), 16) / 255)
        table.insert(color, (#s == 8) and tonumber(s:sub(7, 8), 16) / 255 or 1)
    end

    return color
end

--- Functions to validate the form of color strings and numbers
-- @submodule color

--- Checks if a CSS hex code is formatted properly.
-- Uses character and length matching to assert that the hex code is
-- formatted correctly. Works for rgb, rgba, rrggbb, and rrggbbaa hex
-- codes. Outputs true if correct and false if malformed.
-- @tparam string s A hex code formatted as #rgb, #rgba, #rrggbb, or
-- #rrggbbaa with or without the leading # symbol
-- @treturn boolean true if correctly formatted, false if not.
-- @usage
-- print(is_valid_hex_code(FFF)) -- true
--
-- print(is_valid_hex_code(#J37N)) -- false
function is_valid_hex_code(s)
    s = s:gsub("#", "")
    local invalidChars = string.match(s, "[^0-9a-fA-F]+")
    local hasValidChars = invalidChars == nil
    local isValidLen = #s == 3 or #s == 4 or #s == 6 or #s == 8
    return hasValidChars and isValidLen
end

--- Draw, move, scale, and color basic shapes.
-- These functions draw, move, scale, and color shapes on the Canvas node.
-- There are also several built-in theme values that represent color tables
-- matching the style of Audulus. The Audulus-Canvas library is extends the
-- usefulness of these built-ins by adding additional abstraction layers and
-- utility functions that simplify complex drawing operations.
-- @module builtins

-- Note: If you would like to see the source code for these functions, you can
-- view it at https://github.com/audulus/vger.

--- Returns a paint userdata from a color table.
-- Creates a userdata called paint that represents an rgba color. Paints are
-- used to color all of the SVG shapes. It is good practice to keep colors
-- values as color values right up until you need them to be paints, usually
-- just one line before you actually draw the shape that takes a paint. This is
-- because you cannot index into and manipulate the rgba values of a paint.
-- @tparam table color_table An {r, g, b, a} color table where each variable is
-- a normalized 0 to 1 value.
-- @treturn userdata A paint userdata.
-- @usage
-- white = {1, 1, 1, 1}
-- paint = color_paint(white)
-- fill_circle({0, 0}, 10, paint) -- white circle
--
-- -- In this example, sine is a Canvas node input and is a 0 to 1 sine wave
-- pulsing_red = {sine, 0, 0, 1}
-- pulsing_red_paint = color_paint(pulsing_red)
-- fill_rect({0, 0}, {40, 10}, 0, pulsing_red_paint) --
--
-- print(white[1]) -- 1
-- print(paint[1]) -- Error: attempt to index global 'white' (a userdata value)
function color_paint(color_table)
end

--- Returns a linear gradient paint from two color tables and a set of coordinates.
function linear_gradient(start_coord, end_coord, color_start, color_end)
end

--- Draws a solid circle.
function fill_circle(coordinate, radius, paint)
end

--- Draws an outlined circle.
function stroke_circle(coordinate, radius, width, paint)
end

--- Draws an arc.
function stroke_arc(coordinate, radius, width, rotation, aperture, paint)
end

--- Draws a line.
function stroke_segment(a, b, width, paint)
end

--- Draws a solid rectangle.
function fill_rect(min, max, corner_radius, paint)
end

--- Draws an outlined rectangle.
function stroke_rect(min, max, corner_radius, width, paint)
end

--- Draws a quadratic bezier curve.
function stroke_bezier(a, b, c, width, paint)
end

--- Draws a string.
function text(s, color_table)
end

--- Returns the minimum and maximum of a string.
function text_bounds(s)
end

--- Draws a string in a text box.
function text_box(s, break_row_width, color_table)
end

--- Pick up the pen and move to coordinate {x, y}
function move_to(coordinate)
end

--- Draw a line from current pen position to coordinate {x, y}
function line_to(coordinate)
end

--- Draw a quadratic bezier curve from current pen position to coord_c
function quad_to(coord_b, coord_c)
end

--- Fill the space enclosed by the pen with a paint color.
function fill(paint)
end

--- Translate the coordinate system by an offset set by the coordinate {tx, ty}
function translate(coordinate)
end

--- Grow (>1) or shrink (<1) the x and y axes independently with the coordinate
function scale(coordinate)
end

--- Rotates the canvas around the origin by radians.
-- Positive to left, negative to right.
function rotate(theta)
end

--- Saves the coordinate system state.
function save()
end

--- Restores the coordinate system state to the point where it was saved.
function restore()
end

-- canvas_width
-- canvas_height

-- theme.azureHighlight
-- theme.azureHighlightDark
-- theme.azureHighlightBackground

-- theme.greenHighlight
-- theme.greenHighlightDark
-- theme.azureHighlightBackground

-- theme.redHighlight
-- theme.redHighlightDark
-- theme.redHighlightBackground

-- theme.grooves
-- theme.modules
-- theme.text


Vec2 = {}
Vec2.__index = Vec2

function Vec2.new(x, y)
    local self = setmetatable({}, Vec2)
    self.x = x or 0
    self.y = y or 0
    return self
end

local function is_vec(v)
    return type(v) == "table" and v.x and v.y
end

local function is_num_pair(x, y)
    return type(x) == "number" and type(y) == "number"
end

function Vec2:add(x, y)
    if is_vec(x) then
        return Vec2.new(self.x + x.x, self.y + x.y)
    elseif is_num_pair(x, y) then
        return Vec2.new(self.x + x, self.y + y)
    else
        error("TypeError: Invalid arguments for Vec2:add")
    end
end

function Vec2:Add(x, y)
    if is_vec(x) then
        self.x = self.x + x.x
        self.y = self.y + x.y
        return self
    elseif is_num_pair(x, y) then
        self.x = self.x + x
        self.y = self.y + y
        return self
    else
        error("TypeError: Invalid arguments for Vec2:Add")
    end
end

function Vec2:sub(x, y)
    if is_vec(x) then
        return Vec2.new(self.x - x.x, self.y - x.y)
    elseif is_num_pair(x, y) then
        return Vec2.new(self.x - x, self.y - y)
    else
        error("TypeError: Invalid arguments for Vec2:sub")
    end
end

function Vec2:Sub(x, y)
    if is_vec(x) then
        self.x = self.x - x.x
        self.y = self.y - y.y
        return self
    elseif is_num_pair(x, y) then
        self.x = self.x - x
        self.y = self.y - y
        return self
    else
        error("TypeError: Invalid arguments for Vec2:Sub")
    end
end

function Vec2:mult(scalar)
    return Vec2.new(self.x * scalar, self.y * scalar)
end

function Vec2:Mult(scalar)
    self.x = self.x * scalar
    self.y = self.y * scalar
    return self
end

function Vec2:magnitude()
    return math.sqrt(self.x * self.x + self.y * self.y)
end

function Vec2:normalize()
    local mag = self:magnitude()
    if mag > 0 then
        return Vec2.new(self.x / mag, self.y / mag)
    else
        return Vec2.new(0, 0)
    end
end

function Vec2:dot(other)
    return self.x * other.x + self.y * other.y
end

function Vec2:angle(other)
    local dot_product = self:dot(other)
    local mag_product = self:magnitude() * other:magnitude()
    if mag_product > 0 then
        return math.acos(dot_product / mag_product)
    else
        return 0
    end
end

function Vec2:rotate(angle)
    local cos_theta = math.cos(angle)
    local sin_theta = math.sin(angle)
    return Vec2.new(
        self.x * cos_theta - self.y * sin_theta,
        self.x * sin_theta + self.y * cos_theta
    )
end

function Vec2:Rotate(angle)
    local cos_theta = math.cos(angle)
    local sin_theta = math.sin(angle)
    self.x = self.x * cos_theta - self.y * sin_theta
    self.y = self.x * sin_theta + self.y * cos_theta
    return self
end

function Vec2:distance(other)
    if is_vec(other) then
        local dx = self.x - other.x
        local dy = self.y - other.y
        return math.sqrt(dx * dx + dy * dy)
    else
        error("TypeError: Argument for Vec2:distance must be a Vec2")
    end
end

Point = {}
Point.__index = Point

function Point.new(vec2, color, size)
    local self = setmetatable({}, Point)
    self.vec2 = vec2 or { x = 0, y = 0 }
    self.color = color or { 1, 1, 1, 1 }
    self.size = size or 2
    return self
end

local function process_args(class_meta, ...)
    local args = { ... }
    local processed_args

    if type(args[1]) == "table" then
        if getmetatable(args[1]) == class_meta then
            processed_args = args
        else
            processed_args = args[1]
        end
    else
        processed_args = args
    end

    return processed_args
end

function Point.draw_all(...)
    local points = process_args(Point, ...)

    for _, point in ipairs(points) do
        if getmetatable(point) == Point then
            point:draw()
        else
            error("Invalid argument to Point.draw_all:" ..
                "Expected a Point instance or a table of Point instances")
        end
    end
end

function Point:draw()
    fill_circle({ self.vec2.x, self.vec2.y },
        self.size,
        color_paint(self.color)
    )
end

function fill_triangle(vec2_a, vec2_b, vec2_c, paint)
    move_to(vec2_a)
    line_to(vec2_b)
    line_to(vec2_c)
    line_to(vec2_a)
    fill(paint)
end

Line = {}
Line.__index = Line

function Line.new(vec2_a, vec2_b)
    local self = setmetatable({}, Line)
    self.vec2_a = vec2_a or { 0, 0 }
    self.vec2_b = vec2_b or { 0, 0 }
    return self
end

local function process_args(class_meta, ...)
    local args = { ... }
    local processed_args

    if type(args[1]) == "table" then
        if getmetatable(args[1]) == class_meta then
            processed_args = args
        else
            processed_args = args[1]
        end
    else
        processed_args = args
    end

    return processed_args
end

function Line.draw_between_all(...)
    local vec2s = process_args(Line, ...)
    for i = 1, #vec2s do
        for j = i + 1, #vec2s do
            local line = Line.new(vec2s[i], vec2s[j])
            line:draw()
        end
    end
end

function Line.draw_from_to_all(vec2, ...)
    local vec2s = process_args(Line, ...)
    for i = 1, #vec2s do
        local line = Line.new(vec2, vec2s[i])
        line:draw()
    end
end

function Line:draw(color, width)
    color = color or theme.text
    width = width or 1
    local paint = color_paint(color)
    stroke_segment(
        { self.vec2_a.x, self.vec2_a.y },
        { self.vec2_b.x, self.vec2_b.y },
        width, paint
    )
end

function Line:dashed(color, width, dash_length, space_length)
    color = color or theme.text
    width = width or 1
    dash_length = dash_length or 5
    space_length = space_length or dash_length
    local paint = color_paint(color)

    local total_distance = self.vec2_a:distance(self.vec2_b)
    local direction = self.vec2_b:sub(self.vec2_a):normalize()

    local current_distance = 0
    while current_distance < total_distance do
        local start_dash = self.vec2_a:add(direction:mult(current_distance))
        current_distance = math.min(current_distance + dash_length, total_distance)
        local end_dash = self.vec2_a:add(direction:mult(current_distance))

        local temp_line = Line.new(start_dash, end_dash)
        temp_line:draw(color, width)

        current_distance = current_distance + space_length
    end
end

function button(x, y, width, options)
    -- Error Handling
    local function checkMutuallyExclusiveArgs(arg1Name, arg1, arg2Name, arg2)
        local e = "MutuallyExclusiveArgError: '%s' and '%s' cannot be used" ..
            "together. Remove one or the other."
        if arg1 and arg2 then
            error(string.format(e, arg1Name, arg2Name))
        end
    end

    -- Optional Keyword Arguments
    local o = options or {}
    local height = o.height or width
    local id = o.id or 0
    local c = o.color or { 1, 1, 1, 1 }

    -- Corner Radius
    local r = o.radius or nil
    local pRadius = o.pRadius or false
    if pRadius then
        checkMutuallyExclusiveArgs("radius", r, "pRadius", pRadius)
        local pRadiusPercent = math.min(o.pRadiusPercent or 10, 50)
        r = width * (pRadiusPercent / 100)
    else
        if r ~= nil and r > width then
            error(string.format("ValueError: Radius cannot exceed size." ..
                "Max: %d, " ..
                "Provided: %d",
                width, r))
        end
    end
    local radius = r or 0

    -- Border
    local border = o.border or false
    local borderWidth = o.borderWidth or 1
    local borderColor = o.borderColor or
        { c[1] * 0.75, c[2] * 0.75, c[3] * 0.75, c[4] }

    -- Initialize coordinates
    local x1 = x
    local y1 = y
    local x2 = x + width
    local y2 = y + height

    -- Touch detector
    local btnTouched = tX >= x1 and tX <= x2 and tY >= y1 and tY <= y2 and t > 0

    -- Shrink on press
    local shrinkOnPress = o.shrinkOnPress or false
    if shrinkOnPress and btnTouched then
        local shrinkPercent = o.shrinkPercent or 90
        local sP = shrinkPercent / 100
        local dX = (x2 - x1) * (1 - sP) / 2
        local dY = (y2 - y1) * (1 - sP) / 2
        x1 = x1 + dX
        y1 = y1 + dY
        x2 = x2 - dX
        y2 = y2 - dY
    end

    -- Padding
    local p = o.pad or nil
    local pPad = o.pPad or false
    if pPad then
        checkMutuallyExclusiveArgs("pad", p, "pPad", pPad)
        local pPadPercent = o.pPadPercent or 5
        p = width * (pPadPercent / 100)
    end
    local pad = p or 0
    x1 = x1 + pad
    y1 = y1 + pad
    x2 = x2 - pad
    y2 = y2 - pad

    -- Pack coordinates
    local pA = { x1, y1 }
    local pB = { x2, y2 }

    -- Draw
    local function drawButton()
        local br = btnTouched and 1 or 0
        local st = grid[id] * 0.5
        local f = math.max(0, math.min(br + st, 1))
        local paint = color_paint(
            { c[1] * f, c[2] * f, c[3] * f, c[4] }
        )
        if not border then
            fill_rect(pA, pB, radius, paint)
        else
            -- Border
            fill_rect(pA, pB, radius, color_paint(borderColor))

            -- Adjust the radius as border gets thicker
            local innerWidth = x2 - x1 - borderWidth
            local innerHeight = y2 - y1 - borderWidth
            local scaleFactor = math.min(innerWidth / (x2 - x1),
                innerHeight / (y2 - y1))
            local adjustedRadius = radius * scaleFactor

            -- Inner rectangle
            local hBW = borderWidth / 2
            local pAB = { x1 + hBW, y1 + hBW }
            local pBB = { x2 - hBW, y2 - hBW }
            fill_rect(pAB, pBB, adjustedRadius, paint)
        end
    end

    drawButton()
end

function tile_button_fn(func, r, c)
    return function(x, y, w, o)
        local h = o.height or w
        for i = 0, c - 1 do
            for j = 0, r - 1 do
                o.id = i + 1 + j * c
                func(x + i * w, y + j * h, w, o)
            end
        end
    end
end

--- Useful debugging functions.
-- @module debug

--- Returns a set of functions that together enable stdout-like printing.
-- The built-in Lua print() function can't print anywhere in Audulus. This
-- function enables you to add in a stdout-like experience in Audulus. The
-- function creates two functions (normally named print and printAll) that
-- assist in printing variables beneath the Canvas node. print() will add a
-- variable or value to the print queue. Use print() just as you would in any
-- any other program. Then, call printAll() at the very end of your script to
-- display the print queue. Each print item is numbered in the order it was
-- called starting at 1. Additionally, displays the current memory usage.
-- @treturn function add_to_queue Adds variable to print queue.
-- @treturn function print_queue Prints the queue beneath the Canvas node.
-- @usage
-- print, printAll = create_print_logger()
--
-- x = 1 + 1
-- print(x)
--
-- color = {0.5, 0.75, 0.1, 1}
-- print(color)
--
-- coordinate = {x = 1, y = 12}
-- print(coordinate)
--
-- printAll()
-- -- (Note: This appears below the Canvas node) --
-- -- Memory usage (KB): 72
-- -- Print Queue Output
-- -- _________________
-- -- 1. 2
-- -- 2. {0.5, 0.75, 0.1, 1}
-- -- 3. {x = 1, y = 12}
function create_print_logger()
    local queue = {}

    local function has_non_integer_keys(t)
        for k, _ in pairs(t) do
            if type(k) ~= "number" or k ~= math.floor(k) or k < 1 then
                return true
            end
        end
        return false
    end

    local function table_to_string(t)
        local parts = {}
        if has_non_integer_keys(t) then
            for k, v in pairs(t) do
                parts[#parts + 1] = tostring(k) .. " = " .. tostring(v)
            end
        else
            for _, v in ipairs(t) do
                parts[#parts + 1] = tostring(v)
            end
        end
        return "{ " .. table.concat(parts, ", ") .. " }"
    end

    local function add_to_queue(...)
        local args = { ... }
        local statements = {}

        for i, arg in ipairs(args) do
            statements[i] = (type(arg) == "table")
                and table_to_string(arg) or tostring(arg)
        end

        table.insert(queue, table.concat(statements, ", "))
    end

    local function get_peak_memory(interval)
        if _PeakMemory == nil then
            _PeakMemory = math.floor(collectgarbage("count"))
        end

        if Time == nil then Time = 0 end
        local current_memory_usage = math.floor(collectgarbage("count"))
        local truncated_time = math.floor(Time * 100) / 100

        if _PeakMemory < current_memory_usage then
            _PeakMemory = current_memory_usage
        end

        if truncated_time % interval == 0 then _PeakMemory = 0 end

        return _PeakMemory
    end

    local function print_queue()
        translate { 0, -30 }
        text("Peak memory usage (KB): " .. get_peak_memory(10), theme.text)
        translate { 0, -20 }
        text("Print Queue Output", theme.text)
        translate { 0, -4 }
        text("_________________", theme.text)
        translate { 0, -20 }

        for i, s in ipairs(queue) do
            text(i .. ": " .. s, theme.text)
            translate { 0, -14 }
        end
    end

    return add_to_queue, print_queue
end

Graph = {}
Graph.__index = Graph

function Graph.new(x_max, y_max, step, color)
    local self = setmetatable({}, Graph)
    self.x_max = x_max or 100
    self.y_max = y_max or 100
    self.step = step or 10
    self.color = color or { 0.4, 0.4, 0.4, 1 }
    return self
end

function Graph:draw()
    local paint = color_paint(self.color)

    for i = 0, self.step * self.step * 2, self.step do
        stroke_segment({ -self.x_max, -self.y_max + i }, { self.x_max, -self.y_max + i }, 1, paint)
        stroke_segment({ -self.x_max + i, -self.y_max }, { -self.x_max + i, self.y_max }, 1, paint)
    end

    stroke_segment({ -self.x_max, 0 }, { self.x_max, 0 }, 2, paint)
    stroke_segment({ 0, self.y_max }, { 0, -self.y_max }, 2, paint)
end
